{"name":"Fast-serialization","tagline":"FST: fast java serialization drop in-replacement","body":"fast-serialization\r\n==================\r\n\r\n  * **Fast Serialization** reimplements Java Serialization with focus on speed, size and compatibility. This allows the use of FST with minimal code change. \r\n  * **FSTStructs** implements a struct emulation to avoid de-/encoding completely. Use case is high performance message oriented software, huge (>32GB) of static offheap data, data exchange with other languages, reduction of FullGC by 'flattening' or offheaping complex object graphs, Control of data locality (CPU cache friendly) for high performance computational tasks, allocation free java programs. \r\n\r\n#### features:\r\n\r\n  * Faster serialization and smaller object size. \r\n  * **drop-in replacement**. Does not require special getters/setters/Constructors/Interfaces to serialize a class. Extends Outputstream, implements `ObjectInput/ObjectOutput`. Few code changes required.\r\n  * Full support of JDK-serialization features such as Externalizable writeObject/readObject/readReplace/validation/putField/getField, hooks etc.. If an object is serializable with JDK, it should be serializable with FST without any further work.\r\n  * preserves links inside the serialized object graph same as JDK default serialization\r\n  * custom optimization using *annotations*, custom serializers\r\n  * conditional decoding (skip decoding parts of an object/stream in case)\r\n\r\nSupports java 1.7+\r\n  * Fast serialization should be adaptable to 1.6 (no use of 1.7 features)\r\n  * FST-structs does require 1.7 API\r\n\r\n#### Maven, Download\r\n\r\ndownload non-maven build at the releases section:\r\nhttps://github.com/RuedigerMoeller/fast-serialization/releases/\r\n\r\nNote: fixes+updates are delivered with some delay to maven central, check downloads first\r\nfor newest version\r\n```xml\r\n<dependency>\r\n    <groupId>de.ruedigermoeller</groupId>\r\n    <artifactId>fst</artifactId>\r\n    <version>1.40</version>\r\n</dependency>\r\n```\r\n\r\n#### State of this project\r\n\r\nFST Serialization should be pretty stable and JDK-serialization compatible today. It is used in a large distributed [high performance application](http://java-is-the-new-c.blogspot.de/2013/12/big-data-reactive-way.html). Additionally a lot of remaining corner cases (mostly JDK-serialization-compatibility-issues) have been fixed when replacing JDK-serialization in a prime-faces webflow webapp (lot's of rarely used constructs in there).\r\n\r\n#### Documentation\r\n\r\nsee [Wiki](https://github.com/RuedigerMoeller/fast-serialization/wiki), some documents are still not moved/ported from https://code.google.com/p/fast-serialization/. Read them there.\r\n\r\nAlso see this [blog post](http://java-is-the-new-c.blogspot.de/2013/10/still-using-externalizable-to-get.html).\r\n\r\n#### Limits\r\n  * specialized on java-to-java, no inter language operability.\r\n  * no support for versioning. Reader and writer need to have identical versions of the classes serialized.\r\n  * reads/writes to a temporary buffer in memory to speed up things. This might impose a problem when reading/writing huge objects > 100MB\r\n  * emulating JDK built in `Externalizable` is somewhat tricky. FST needs to speculate on the maximum size of a single externalizable instance. Default setting is 8kb. In case you use `Externalizable` and write large binary data from one single `Externalizable` instance without return control to the serializer, you have to increase both `externalReadAhead` and `externalWriteAhead` at the `FSTObjectOutput` and `FSTObjectInput` class. You might also consider to just replace `Externalizable` by `Serializable`. In fact FST frequently does `Serializable` faster than built in JDK `Externalizable` implementations.\r\n\r\n#### Benchmark\r\n\r\nI measure different typical use cases (both classes with lots of native data and structural complex object graphs). The benchmarks assures, that only serialization speed is measured. Creation of `ByteArrayStreams` etc. is not included in the benchmark times. Additionally for each library best efforts are made to use them in the best possible way (e.g. reuse heavy weight objects if possible).\r\n\r\n[current results](https://github.com/RuedigerMoeller/fast-serialization/wiki/Benchmark)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}